/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Scott Morrison, Johannes H√∂lzl
-/
import category_theory.functor_category
import category_theory.fully_faithful
import data.equiv.basic

namespace category_theory

universes v v' w u u' -- declare the `v`'s first; see `category_theory.category` for an explanation

instance types : large_category (Type u) :=
{ hom     := Œª a b, (a ‚Üí b),
  id      := Œª a, id,
  comp    := Œª _ _ _ f g, g ‚àò f }

@[simp] lemma types_hom {Œ± Œ≤ : Type u} : (Œ± ‚ü∂ Œ≤) = (Œ± ‚Üí Œ≤) := rfl
@[simp] lemma types_id (X : Type u) : ùüô X = id := rfl
@[simp] lemma types_comp {X Y Z : Type u} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : f ‚â´ g = g ‚àò f := rfl

namespace functor
variables {J : Type u} [ùí• : category.{v} J]
include ùí•

def sections (F : J ‚•§ Type w) : set (Œ† j, F.obj j) :=
{ u | ‚àÄ {j j'} (f : j ‚ü∂ j'), F.map f (u j) = u j'}
end functor

namespace functor_to_types
variables {C : Type u} [ùíû : category.{v} C] (F G H : C ‚•§ Type w) {X Y Z : C}
include ùíû
variables (œÉ : F ‚ü∂ G) (œÑ : G ‚ü∂ H)

@[simp] lemma map_comp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (a : F.obj X) : (F.map (f ‚â´ g)) a = (F.map g) ((F.map f) a) :=
by simp

@[simp] lemma map_id (a : F.obj X) : (F.map (ùüô X)) a = a :=
by simp

lemma naturality (f : X ‚ü∂ Y) (x : F.obj X) : œÉ.app Y ((F.map f) x) = (G.map f) (œÉ.app X x) :=
congr_fun (œÉ.naturality f) x

@[simp] lemma comp (x : F.obj X) : (œÉ ‚â´ œÑ).app X x = œÑ.app X (œÉ.app X x) := rfl

variables {D : Type u'} [ùíü : category.{u'} D] (I J : D ‚•§ C) (œÅ : I ‚ü∂ J) {W : D}

@[simp] lemma hcomp (x : (I ‚ãô F).obj W) : (œÅ ‚ó´ œÉ).app W x = (G.map (œÅ.app W)) (œÉ.app (I.obj W) x) := rfl

end functor_to_types

def ulift_trivial (V : Type u) : ulift.{u} V ‚âÖ V := by tidy

def ulift_functor : Type u ‚•§ Type (max u v) :=
{ obj := Œª X, ulift.{v} X,
  map := Œª X Y f, Œª x : ulift.{v} X, ulift.up (f x.down) }

@[simp] lemma ulift_functor_map {X Y : Type u} (f : X ‚ü∂ Y) (x : ulift.{v} X) :
  ulift_functor.map f x = ulift.up (f x.down) := rfl

instance ulift_functor_full : full ulift_functor :=
{ preimage := Œª X Y f x, (f (ulift.up x)).down }
instance ulift_functor_faithful : faithful ulift_functor :=
{ injectivity' := Œª X Y f g p, funext $ Œª x,
    congr_arg ulift.down ((congr_fun p (ulift.up x)) : ((ulift.up (f x)) = (ulift.up (g x)))) }

def hom_of_element {X : Type u} (x : X) : punit ‚ü∂ X := Œª _, x

lemma hom_of_element_eq_iff {X : Type u} (x y : X) :
  hom_of_element x = hom_of_element y ‚Üî x = y :=
‚ü®Œª H, congr_fun H punit.star, by cc‚ü©

lemma mono_iff_injective {X Y : Type u} (f : X ‚ü∂ Y) : mono f ‚Üî function.injective f :=
begin
  split,
  { intros H x x' h,
    resetI,
    rw ‚Üêhom_of_element_eq_iff at ‚ä¢ h,
    exact (cancel_mono f).mp h },
  { refine Œª H, ‚ü®Œª Z g h H‚ÇÇ, _‚ü©,
    ext z,
    replace H‚ÇÇ := congr_fun H‚ÇÇ z,
    exact H H‚ÇÇ }
end

lemma epi_iff_surjective {X Y : Type u} (f : X ‚ü∂ Y) : epi f ‚Üî function.surjective f :=
begin
  split,
  { intros H,
    let g : Y ‚ü∂ ulift Prop := Œª y, ‚ü®true‚ü©,
    let h : Y ‚ü∂ ulift Prop := Œª y, ‚ü®‚àÉ x, f x = y‚ü©,
    suffices : f ‚â´ g = f ‚â´ h,
    { resetI,
      rw cancel_epi at this,
      intro y,
      replace this := congr_fun this y,
      replace this : true = ‚àÉ x, f x = y := congr_arg ulift.down this,
      rw ‚Üêthis,
      trivial },
    ext x,
    change true ‚Üî ‚àÉ x', f x' = f x,
    rw true_iff,
    exact ‚ü®x, rfl‚ü© },
  { intro H,
    constructor,
    intros Z g h H‚ÇÇ,
    apply funext,
    rw ‚Üêforall_iff_forall_surj H,
    intro x,
    exact (congr_fun H‚ÇÇ x : _) }
end

section

/-- `of_type_functor m` converts from Lean's `Type`-based `category` to `category_theory`. This
allows us to use these functors in category theory. -/
def of_type_functor (m : Type u ‚Üí Type v) [_root_.functor m] [is_lawful_functor m] :
  Type u ‚•§ Type v :=
{ obj       := m,
  map       := ŒªŒ± Œ≤, _root_.functor.map,
  map_id'   := assume Œ±, _root_.functor.map_id,
  map_comp' := assume Œ± Œ≤ Œ≥ f g, funext $ assume a, is_lawful_functor.comp_map f g _ }

variables (m : Type u ‚Üí Type v) [_root_.functor m] [is_lawful_functor m]

@[simp]
lemma of_type_functor_obj : (of_type_functor m).obj = m := rfl

@[simp]
lemma of_type_functor_map {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) :
  (of_type_functor m).map f = (_root_.functor.map f : m Œ± ‚Üí m Œ≤) := rfl

end

end category_theory

-- Isomorphisms in Type and equivalences.

namespace equiv

universe u

variables {X Y : Type u}

def to_iso (e : X ‚âÉ Y) : X ‚âÖ Y :=
{ hom := e.to_fun,
  inv := e.inv_fun,
  hom_inv_id' := funext e.left_inv,
  inv_hom_id' := funext e.right_inv }

@[simp] lemma to_iso_hom {e : X ‚âÉ Y} : e.to_iso.hom = e := rfl
@[simp] lemma to_iso_inv {e : X ‚âÉ Y} : e.to_iso.inv = e.symm := rfl

end equiv

namespace category_theory.iso

universe u

variables {X Y : Type u}

def to_equiv (i : X ‚âÖ Y) : X ‚âÉ Y :=
{ to_fun := i.hom,
  inv_fun := i.inv,
  left_inv := Œª x, congr_fun i.hom_inv_id x,
  right_inv := Œª y, congr_fun i.inv_hom_id y }

@[simp] lemma to_equiv_fun (i : X ‚âÖ Y) : (i.to_equiv : X ‚Üí Y) = i.hom := rfl
@[simp] lemma to_equiv_symm_fun (i : X ‚âÖ Y) : (i.to_equiv.symm : Y ‚Üí X) = i.inv := rfl

end category_theory.iso


universe u

-- We prove `equiv_iso_iso` and then use that to sneakily construct `equiv_equiv_iso`.
-- (In this order the proofs are handled by `obviously`.)

/-- equivalences (between types in the same universe) are the same as (isomorphic to) isomorphisms of types -/
@[simps] def equiv_iso_iso {X Y : Type u} : (X ‚âÉ Y) ‚âÖ (X ‚âÖ Y) :=
{ hom := Œª e, e.to_iso,
  inv := Œª i, i.to_equiv, }

/-- equivalences (between types in the same universe) are the same as (equivalent to) isomorphisms of types -/
-- We leave `X` and `Y` as explicit arguments here, because the coercions from `equiv` to a function won't fire without them.
def equiv_equiv_iso (X Y : Type u) : (X ‚âÉ Y) ‚âÉ (X ‚âÖ Y) :=
(equiv_iso_iso).to_equiv

@[simp] lemma equiv_equiv_iso_hom {X Y : Type u} (e : X ‚âÉ Y) : (equiv_equiv_iso X Y) e = e.to_iso := rfl
@[simp] lemma equiv_equiv_iso_inv {X Y : Type u} (e : X ‚âÖ Y) : (equiv_equiv_iso X Y).symm e = e.to_equiv := rfl
