/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot

Theory of uniform spaces.

Uniform spaces are a generalization of metric spaces and topological groups. Many concepts directly
generalize to uniform spaces, e.g.

* completeness
* extension of uniform continuous functions to complete spaces
* uniform contiunuity & embedding
* totally bounded
* totally bounded ‚àß complete ‚Üí compact

The central concept of uniform spaces is its uniformity: a filter relating two elements of the
space. This filter is reflexive, symmetric and transitive. So a set (i.e. a relation) in this filter
represents a 'distance': it is reflexive, symmetric and the uniformity contains a set for which the
`triangular` rule holds.

The formalization is mostly based on the books:
  N. Bourbaki: General Topology
  I. M. James: Topologies and Uniformities
A major difference is that this formalization is heavily based on the filter library.
-/
import order.filter.basic order.filter.lift topology.separation

open set lattice filter classical
open_locale classical topological_space

set_option eqn_compiler.zeta true

universes u
section
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œ¥ : Type*} {Œπ : Sort*}

/-- The identity relation, or the graph of the identity function -/
def id_rel {Œ± : Type*} := {p : Œ± √ó Œ± | p.1 = p.2}

@[simp] theorem mem_id_rel {a b : Œ±} : (a, b) ‚àà @id_rel Œ± ‚Üî a = b := iff.rfl

@[simp] theorem id_rel_subset {s : set (Œ± √ó Œ±)} : id_rel ‚äÜ s ‚Üî ‚àÄ a, (a, a) ‚àà s :=
by simp [subset_def]; exact forall_congr (Œª a, by simp)

/-- The composition of relations -/
def comp_rel {Œ± : Type u} (r‚ÇÅ r‚ÇÇ : set (Œ±√óŒ±)) := {p : Œ± √ó Œ± | ‚àÉz:Œ±, (p.1, z) ‚àà r‚ÇÅ ‚àß (z, p.2) ‚àà r‚ÇÇ}

@[simp] theorem mem_comp_rel {r‚ÇÅ r‚ÇÇ : set (Œ±√óŒ±)}
  {x y : Œ±} : (x, y) ‚àà comp_rel r‚ÇÅ r‚ÇÇ ‚Üî ‚àÉ z, (x, z) ‚àà r‚ÇÅ ‚àß (z, y) ‚àà r‚ÇÇ := iff.rfl

@[simp] theorem swap_id_rel : prod.swap '' id_rel = @id_rel Œ± :=
set.ext $ assume ‚ü®a, b‚ü©, by simp [image_swap_eq_preimage_swap]; exact eq_comm

theorem monotone_comp_rel [preorder Œ≤] {f g : Œ≤ ‚Üí set (Œ±√óŒ±)}
  (hf : monotone f) (hg : monotone g) : monotone (Œªx, comp_rel (f x) (g x)) :=
assume a b h p ‚ü®z, h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®z, hf h h‚ÇÅ, hg h h‚ÇÇ‚ü©

lemma prod_mk_mem_comp_rel {a b c : Œ±} {s t : set (Œ±√óŒ±)} (h‚ÇÅ : (a, c) ‚àà s) (h‚ÇÇ : (c, b) ‚àà t) :
  (a, b) ‚àà comp_rel s t :=
‚ü®c, h‚ÇÅ, h‚ÇÇ‚ü©

@[simp] lemma id_comp_rel {r : set (Œ±√óŒ±)} : comp_rel id_rel r = r :=
set.ext $ assume ‚ü®a, b‚ü©, by simp

lemma comp_rel_assoc {r s t : set (Œ±√óŒ±)} :
  comp_rel (comp_rel r s) t = comp_rel r (comp_rel s t) :=
by ext p; cases p; simp only [mem_comp_rel]; tauto

/-- This core description of a uniform space is outside of the type class hierarchy. It is useful
  for constructions of uniform spaces, when the topology is derived from the uniform space. -/
structure uniform_space.core (Œ± : Type u) :=
(uniformity : filter (Œ± √ó Œ±))
(refl       : principal id_rel ‚â§ uniformity)
(symm       : tendsto prod.swap uniformity uniformity)
(comp       : uniformity.lift' (Œªs, comp_rel s s) ‚â§ uniformity)

/-- An alternative constructor for `uniform_space.core`. This version unfolds various
`filter`-related definitions. -/
def uniform_space.core.mk' {Œ± : Type u} (U : filter (Œ± √ó Œ±))
  (refl : ‚àÄ (r ‚àà U) x, (x, x) ‚àà r)
  (symm : ‚àÄ r ‚àà U, {p | prod.swap p ‚àà r} ‚àà U)
  (comp : ‚àÄ r ‚àà U, ‚àÉ t ‚àà U, comp_rel t t ‚äÜ r) : uniform_space.core Œ± :=
‚ü®U, Œª r ru, id_rel_subset.2 (refl _ ru), symm,
  begin
    intros r ru,
    rw [mem_lift'_sets],
    exact comp _ ru,
    apply monotone_comp_rel; exact monotone_id,
  end‚ü©

/-- A uniform space generates a topological space -/
def uniform_space.core.to_topological_space {Œ± : Type u} (u : uniform_space.core Œ±) :
  topological_space Œ± :=
{ is_open        := Œªs, ‚àÄx‚ààs, { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà u.uniformity,
  is_open_univ   := by simp; intro; exact univ_mem_sets,
  is_open_inter  :=
    assume s t hs ht x ‚ü®xs, xt‚ü©, by filter_upwards [hs x xs, ht x xt]; simp {contextual := tt},
  is_open_sUnion :=
    assume s hs x ‚ü®t, ts, xt‚ü©, by filter_upwards [hs t ts x xt] assume p ph h, ‚ü®t, ts, ph h‚ü© }

lemma uniform_space.core_eq : ‚àÄ{u‚ÇÅ u‚ÇÇ : uniform_space.core Œ±}, u‚ÇÅ.uniformity = u‚ÇÇ.uniformity ‚Üí u‚ÇÅ = u‚ÇÇ
| ‚ü®u‚ÇÅ, _, _, _‚ü©  ‚ü®u‚ÇÇ, _, _, _‚ü© h := have u‚ÇÅ = u‚ÇÇ, from h, by simp [*]

section prio
set_option default_priority 100 -- see Note [default priority]
/-- A uniform space is a generalization of the "uniform" topological aspects of a
  metric space. It consists of a filter on `Œ± √ó Œ±` called the "uniformity", which
  satisfies properties analogous to the reflexivity, symmetry, and triangle properties
  of a metric.

  A metric space has a natural uniformity, and a uniform space has a natural topology.
  A topological group also has a natural uniformity, even when it is not metrizable. -/
class uniform_space (Œ± : Type u) extends topological_space Œ±, uniform_space.core Œ± :=
(is_open_uniformity : ‚àÄs, is_open s ‚Üî (‚àÄx‚ààs, { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà uniformity))
end prio

@[pattern] def uniform_space.mk' {Œ±} (t : topological_space Œ±)
  (c : uniform_space.core Œ±)
  (is_open_uniformity : ‚àÄs:set Œ±, t.is_open s ‚Üî
    (‚àÄx‚ààs, { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà c.uniformity)) :
  uniform_space Œ± := ‚ü®c, is_open_uniformity‚ü©

/-- Construct a `uniform_space` from a `uniform_space.core`. -/
def uniform_space.of_core {Œ± : Type u} (u : uniform_space.core Œ±) : uniform_space Œ± :=
{ to_core := u,
  to_topological_space := u.to_topological_space,
  is_open_uniformity := assume a, iff.rfl }

/-- Construct a `uniform_space` from a `u : uniform_space.core` and a `topological_space` structure
that is equal to `u.to_topological_space`. -/
def uniform_space.of_core_eq {Œ± : Type u} (u : uniform_space.core Œ±) (t : topological_space Œ±)
  (h : t = u.to_topological_space) : uniform_space Œ± :=
{ to_core := u,
  to_topological_space := t,
  is_open_uniformity := assume a, h.symm ‚ñ∏ iff.rfl }

lemma uniform_space.to_core_to_topological_space (u : uniform_space Œ±) :
  u.to_core.to_topological_space = u.to_topological_space :=
topological_space_eq $ funext $ assume s,
  by rw [uniform_space.core.to_topological_space, uniform_space.is_open_uniformity]

@[ext]
lemma uniform_space_eq : ‚àÄ{u‚ÇÅ u‚ÇÇ : uniform_space Œ±}, u‚ÇÅ.uniformity = u‚ÇÇ.uniformity ‚Üí u‚ÇÅ = u‚ÇÇ
| (uniform_space.mk' t‚ÇÅ u‚ÇÅ o‚ÇÅ)  (uniform_space.mk' t‚ÇÇ u‚ÇÇ o‚ÇÇ) h :=
  have u‚ÇÅ = u‚ÇÇ, from uniform_space.core_eq h,
  have t‚ÇÅ = t‚ÇÇ, from topological_space_eq $ funext $ assume s, by rw [o‚ÇÅ, o‚ÇÇ]; simp [this],
  by simp [*]

lemma uniform_space.of_core_eq_to_core
  (u : uniform_space Œ±) (t : topological_space Œ±) (h : t = u.to_core.to_topological_space) :
  uniform_space.of_core_eq u.to_core t h = u :=
uniform_space_eq rfl

section uniform_space
variables [uniform_space Œ±]

/-- The uniformity is a filter on Œ± √ó Œ± (inferred from an ambient uniform space
  structure on Œ±). -/
def uniformity (Œ± : Type u) [uniform_space Œ±] : filter (Œ± √ó Œ±) :=
  (@uniform_space.to_core Œ± _).uniformity

localized "notation `ùì§` := uniformity" in uniformity

lemma is_open_uniformity {s : set Œ±} :
  is_open s ‚Üî (‚àÄx‚ààs, { p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s } ‚àà ùì§ Œ±) :=
uniform_space.is_open_uniformity s

lemma refl_le_uniformity : principal id_rel ‚â§ ùì§ Œ± :=
(@uniform_space.to_core Œ± _).refl

lemma refl_mem_uniformity {x : Œ±} {s : set (Œ± √ó Œ±)} (h : s ‚àà ùì§ Œ±) :
  (x, x) ‚àà s :=
refl_le_uniformity h rfl

lemma symm_le_uniformity : map (@prod.swap Œ± Œ±) (ùì§ _) ‚â§ (ùì§ _) :=
(@uniform_space.to_core Œ± _).symm

lemma comp_le_uniformity : (ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), comp_rel s s) ‚â§ ùì§ Œ± :=
(@uniform_space.to_core Œ± _).comp

lemma tendsto_swap_uniformity : tendsto (@prod.swap Œ± Œ±) (ùì§ Œ±) (ùì§ Œ±) :=
symm_le_uniformity

lemma tendsto_const_uniformity {a : Œ±} {f : filter Œ≤} : tendsto (Œª _, (a, a)) f (ùì§ Œ±) :=
assume s hs,
show {x | (a, a) ‚àà s} ‚àà f,
  from univ_mem_sets' $ assume b, refl_mem_uniformity hs

lemma comp_mem_uniformity_sets {s : set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :
  ‚àÉ t ‚àà ùì§ Œ±, comp_rel t t ‚äÜ s :=
have s ‚àà (ùì§ Œ±).lift' (Œªt:set (Œ±√óŒ±), comp_rel t t),
  from comp_le_uniformity hs,
(mem_lift'_sets $ monotone_comp_rel monotone_id monotone_id).mp this

lemma symm_of_uniformity {s : set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :
  ‚àÉ t ‚àà ùì§ Œ±, (‚àÄa b, (a, b) ‚àà t ‚Üí (b, a) ‚àà t) ‚àß t ‚äÜ s :=
have preimage prod.swap s ‚àà ùì§ Œ±, from symm_le_uniformity hs,
‚ü®s ‚à© preimage prod.swap s, inter_mem_sets hs this, assume a b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©, inter_subset_left _ _‚ü©

lemma comp_symm_of_uniformity {s : set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :
  ‚àÉ t ‚àà ùì§ Œ±, (‚àÄ{a b}, (a, b) ‚àà t ‚Üí (b, a) ‚àà t) ‚àß comp_rel t t ‚äÜ s :=
let ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := comp_mem_uniformity_sets hs in
let ‚ü®t', ht', ht'‚ÇÅ, ht'‚ÇÇ‚ü© := symm_of_uniformity ht‚ÇÅ in
‚ü®t', ht', ht'‚ÇÅ, subset.trans (monotone_comp_rel monotone_id monotone_id ht'‚ÇÇ) ht‚ÇÇ‚ü©

lemma uniformity_le_symm : ùì§ Œ± ‚â§ (@prod.swap Œ± Œ±) <$> ùì§ Œ± :=
by rw [map_swap_eq_comap_swap];
from map_le_iff_le_comap.1 tendsto_swap_uniformity

lemma uniformity_eq_symm : ùì§ Œ± = (@prod.swap Œ± Œ±) <$> ùì§ Œ± :=
le_antisymm uniformity_le_symm symm_le_uniformity

theorem uniformity_lift_le_swap {g : set (Œ±√óŒ±) ‚Üí filter Œ≤} {f : filter Œ≤} (hg : monotone g)
  (h : (ùì§ Œ±).lift (Œªs, g (preimage prod.swap s)) ‚â§ f) : (ùì§ Œ±).lift g ‚â§ f :=
calc (ùì§ Œ±).lift g ‚â§ (filter.map (@prod.swap Œ± Œ±) $ ùì§ Œ±).lift g :
    lift_mono uniformity_le_symm (le_refl _)
  ... ‚â§ _ :
    by rw [map_lift_eq2 hg, image_swap_eq_preimage_swap]; exact h

lemma uniformity_lift_le_comp {f : set (Œ±√óŒ±) ‚Üí filter Œ≤} (h : monotone f) :
  (ùì§ Œ±).lift (Œªs, f (comp_rel s s)) ‚â§ (ùì§ Œ±).lift f :=
calc (ùì§ Œ±).lift (Œªs, f (comp_rel s s)) =
    ((ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), comp_rel s s)).lift f :
  begin
    rw [lift_lift'_assoc],
    exact monotone_comp_rel monotone_id monotone_id,
    exact h
  end
  ... ‚â§ (ùì§ Œ±).lift f : lift_mono comp_le_uniformity (le_refl _)

lemma comp_le_uniformity3 :
  (ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), comp_rel s (comp_rel s s)) ‚â§ (ùì§ Œ±) :=
calc (ùì§ Œ±).lift' (Œªd, comp_rel d (comp_rel d d)) =
  (ùì§ Œ±).lift (Œªs, (ùì§ Œ±).lift' (Œªt:set(Œ±√óŒ±), comp_rel s (comp_rel t t))) :
  begin
    rw [lift_lift'_same_eq_lift'],
    exact (assume x, monotone_comp_rel monotone_const $ monotone_comp_rel monotone_id monotone_id),
    exact (assume x, monotone_comp_rel monotone_id monotone_const),
  end
  ... ‚â§ (ùì§ Œ±).lift (Œªs, (ùì§ Œ±).lift' (Œªt:set(Œ±√óŒ±), comp_rel s t)) :
    lift_mono' $ assume s hs, @uniformity_lift_le_comp Œ± _ _ (principal ‚àò comp_rel s) $
      monotone_principal.comp (monotone_comp_rel monotone_const monotone_id)
  ... = (ùì§ Œ±).lift' (Œªs:set(Œ±√óŒ±), comp_rel s s) :
    lift_lift'_same_eq_lift'
      (assume s, monotone_comp_rel monotone_const monotone_id)
      (assume s, monotone_comp_rel monotone_id monotone_const)
  ... ‚â§ (ùì§ Œ±) : comp_le_uniformity

lemma filter.has_basis.mem_uniformity_iff {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set (Œ±√óŒ±)}
  (h : (ùì§ Œ±).has_basis p s) {t : set (Œ± √ó Œ±)} :
  t ‚àà ùì§ Œ± ‚Üî ‚àÉ i (hi : p i), ‚àÄ a b, (a, b) ‚àà s i ‚Üí (a, b) ‚àà t :=
h.mem_iff.trans $ by simp only [prod.forall, subset_def]

lemma mem_nhds_uniformity_iff {x : Œ±} {s : set Œ±} :
  s ‚àà ùìù x ‚Üî {p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s} ‚àà ùì§ Œ± :=
‚ü® begin
    simp only [mem_nhds_sets_iff, is_open_uniformity, and_imp, exists_imp_distrib],
    exact assume t ts ht xt, by filter_upwards [ht x xt] assume ‚ü®x', y‚ü© h eq, ts $ h eq
  end,

  assume hs,
  mem_nhds_sets_iff.mpr ‚ü®{x | {p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s} ‚àà ùì§ Œ±},
    assume x' hx', refl_mem_uniformity hx' rfl,
    is_open_uniformity.mpr $ assume x' hx',
      let ‚ü®t, ht, tr‚ü© := comp_mem_uniformity_sets hx' in
      by filter_upwards [ht] assume ‚ü®a, b‚ü© hp' (hax' : a = x'),
      by filter_upwards [ht] assume ‚ü®a, b'‚ü© hp'' (hab : a = b),
      have hp : (x', b) ‚àà t, from hax' ‚ñ∏ hp',
      have (b, b') ‚àà t, from hab ‚ñ∏ hp'',
      have (x', b') ‚àà comp_rel t t, from ‚ü®b, hp, this‚ü©,
      show b' ‚àà s,
        from tr this rfl,
    hs‚ü©‚ü©

lemma nhds_eq_comap_uniformity {x : Œ±} : ùìù x = (ùì§ Œ±).comap (prod.mk x) :=
by ext s; rw [mem_nhds_uniformity_iff, mem_comap_sets]; from iff.intro
  (assume hs, ‚ü®_, hs, assume x hx, hx rfl‚ü©)
  (assume ‚ü®t, h, ht‚ü©, (ùì§ Œ±).sets_of_superset h $
    assume ‚ü®p‚ÇÅ, p‚ÇÇ‚ü© hp (h : p‚ÇÅ = x), ht $ by simp [h.symm, hp])

lemma nhds_basis_uniformity' {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set (Œ± √ó Œ±)} (h : (ùì§ Œ±).has_basis p s) {x : Œ±} :
  (ùìù x).has_basis p (Œª i, {y | (x, y) ‚àà s i}) :=
by { rw [nhds_eq_comap_uniformity], exact h.comap (prod.mk x) }

lemma nhds_basis_uniformity {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set (Œ± √ó Œ±)} (h : (ùì§ Œ±).has_basis p s) {x : Œ±} :
  (ùìù x).has_basis p (Œª i, {y | (y, x) ‚àà s i}) :=
begin
  replace h := h.comap prod.swap,
  rw [‚Üê map_swap_eq_comap_swap, ‚Üê uniformity_eq_symm] at h,
  exact nhds_basis_uniformity' h
end

lemma nhds_eq_uniformity {x : Œ±} : ùìù x = (ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), {y | (x, y) ‚àà s}) :=
(nhds_basis_uniformity' (ùì§ Œ±).basis_sets).eq_binfi

lemma mem_nhds_left (x : Œ±) {s : set (Œ±√óŒ±)} (h : s ‚àà ùì§ Œ±) :
  {y : Œ± | (x, y) ‚àà s} ‚àà ùìù x :=
(nhds_basis_uniformity' (ùì§ Œ±).basis_sets).mem_of_mem h

lemma mem_nhds_right (y : Œ±) {s : set (Œ±√óŒ±)} (h : s ‚àà ùì§ Œ±) :
  {x : Œ± | (x, y) ‚àà s} ‚àà ùìù y :=
mem_nhds_left _ (symm_le_uniformity h)

lemma tendsto_right_nhds_uniformity {a : Œ±} : tendsto (Œªa', (a', a)) (ùìù a) (ùì§ Œ±) :=
assume s, mem_nhds_right a

lemma tendsto_left_nhds_uniformity {a : Œ±} : tendsto (Œªa', (a, a')) (ùìù a) (ùì§ Œ±) :=
assume s, mem_nhds_left a

lemma lift_nhds_left {x : Œ±} {g : set Œ± ‚Üí filter Œ≤} (hg : monotone g) :
  (ùìù x).lift g = (ùì§ Œ±).lift (Œªs:set (Œ±√óŒ±), g {y | (x, y) ‚àà s}) :=
eq.trans
  begin
    rw [nhds_eq_uniformity],
    exact (filter.lift_assoc $ monotone_principal.comp $ monotone_preimage.comp monotone_preimage )
  end
  (congr_arg _ $ funext $ assume s, filter.lift_principal hg)

lemma lift_nhds_right {x : Œ±} {g : set Œ± ‚Üí filter Œ≤} (hg : monotone g) :
  (ùìù x).lift g = (ùì§ Œ±).lift (Œªs:set (Œ±√óŒ±), g {y | (y, x) ‚àà s}) :=
calc (ùìù x).lift g = (ùì§ Œ±).lift (Œªs:set (Œ±√óŒ±), g {y | (x, y) ‚àà s}) : lift_nhds_left hg
  ... = ((@prod.swap Œ± Œ±) <$> (ùì§ Œ±)).lift (Œªs:set (Œ±√óŒ±), g {y | (x, y) ‚àà s}) : by rw [‚Üêuniformity_eq_symm]
  ... = (ùì§ Œ±).lift (Œªs:set (Œ±√óŒ±), g {y | (x, y) ‚àà image prod.swap s}) :
    map_lift_eq2 $ hg.comp monotone_preimage
  ... = _ : by simp [image_swap_eq_preimage_swap]

lemma nhds_nhds_eq_uniformity_uniformity_prod {a b : Œ±} :
  filter.prod (ùìù a) (ùìù b) =
  (ùì§ Œ±).lift (Œªs:set (Œ±√óŒ±), (ùì§ Œ±).lift' (Œªt:set (Œ±√óŒ±),
    set.prod {y : Œ± | (y, a) ‚àà s} {y : Œ± | (b, y) ‚àà t})) :=
begin
  rw [prod_def],
  show (ùìù a).lift (Œªs:set Œ±, (ùìù b).lift (Œªt:set Œ±, principal (set.prod s t))) = _,
  rw [lift_nhds_right],
  apply congr_arg, funext s,
  rw [lift_nhds_left],
  refl,
  exact monotone_principal.comp (monotone_prod monotone_const monotone_id),
  exact (monotone_lift' monotone_const $ monotone_lam $
    assume x, monotone_prod monotone_id monotone_const)
end

lemma nhds_eq_uniformity_prod {a b : Œ±} :
  ùìù (a, b) =
  (ùì§ Œ±).lift' (Œªs:set (Œ±√óŒ±), set.prod {y : Œ± | (y, a) ‚àà s} {y : Œ± | (b, y) ‚àà s}) :=
begin
  rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift'],
  { intro s, exact monotone_prod monotone_const monotone_preimage },
  { intro t, exact monotone_prod monotone_preimage monotone_const }
end

lemma nhdset_of_mem_uniformity {d : set (Œ±√óŒ±)} (s : set (Œ±√óŒ±)) (hd : d ‚àà ùì§ Œ±) :
  ‚àÉ(t : set (Œ±√óŒ±)), is_open t ‚àß s ‚äÜ t ‚àß t ‚äÜ {p | ‚àÉx y, (p.1, x) ‚àà d ‚àß (x, y) ‚àà s ‚àß (y, p.2) ‚àà d} :=
let cl_d := {p:Œ±√óŒ± | ‚àÉx y, (p.1, x) ‚àà d ‚àß (x, y) ‚àà s ‚àß (y, p.2) ‚àà d} in
have ‚àÄp ‚àà s, ‚àÉt ‚äÜ cl_d, is_open t ‚àß p ‚àà t, from
  assume ‚ü®x, y‚ü© hp, mem_nhds_sets_iff.mp $
  show cl_d ‚àà ùìù (x, y),
  begin
    rw [nhds_eq_uniformity_prod, mem_lift'_sets],
    exact ‚ü®d, hd, assume ‚ü®a, b‚ü© ‚ü®ha, hb‚ü©, ‚ü®x, y, ha, hp, hb‚ü©‚ü©,
    exact monotone_prod monotone_preimage monotone_preimage
  end,
have ‚àÉt:(Œ†(p:Œ±√óŒ±) (h:p ‚àà s), set (Œ±√óŒ±)),
    ‚àÄp, ‚àÄh:p ‚àà s, t p h ‚äÜ cl_d ‚àß is_open (t p h) ‚àß p ‚àà t p h,
  by simp [classical.skolem] at this; simp; assumption,
match this with
| ‚ü®t, ht‚ü© :=
  ‚ü®(‚ãÉ p:Œ±√óŒ±, ‚ãÉ h : p ‚àà s, t p h : set (Œ±√óŒ±)),
    is_open_Union $ assume (p:Œ±√óŒ±), is_open_Union $ assume hp, (ht p hp).right.left,
    assume ‚ü®a, b‚ü© hp, begin simp; exact ‚ü®a, b, hp, (ht (a,b) hp).right.right‚ü© end,
    Union_subset $ assume p, Union_subset $ assume hp, (ht p hp).left‚ü©
end

lemma closure_eq_inter_uniformity {t : set (Œ±√óŒ±)} :
  closure t = (‚ãÇ d ‚àà ùì§ Œ±, comp_rel d (comp_rel t d)) :=
set.ext $ assume ‚ü®a, b‚ü©,
calc (a, b) ‚àà closure t ‚Üî (ùìù (a, b) ‚äì principal t ‚â† ‚ä•) : by simp [closure_eq_nhds]
  ... ‚Üî (((@prod.swap Œ± Œ±) <$> ùì§ Œ±).lift'
      (Œª (s : set (Œ± √ó Œ±)), set.prod {x : Œ± | (x, a) ‚àà s} {y : Œ± | (b, y) ‚àà s}) ‚äì principal t ‚â† ‚ä•) :
    by rw [‚Üêuniformity_eq_symm, nhds_eq_uniformity_prod]
  ... ‚Üî ((map (@prod.swap Œ± Œ±) (ùì§ Œ±)).lift'
      (Œª (s : set (Œ± √ó Œ±)), set.prod {x : Œ± | (x, a) ‚àà s} {y : Œ± | (b, y) ‚àà s}) ‚äì principal t ‚â† ‚ä•) :
    by refl
  ... ‚Üî ((ùì§ Œ±).lift'
      (Œª (s : set (Œ± √ó Œ±)), set.prod {y : Œ± | (a, y) ‚àà s} {x : Œ± | (x, b) ‚àà s}) ‚äì principal t ‚â† ‚ä•) :
  begin
    rw [map_lift'_eq2],
    simp [image_swap_eq_preimage_swap, function.comp],
    exact monotone_prod monotone_preimage monotone_preimage
  end
  ... ‚Üî (‚àÄs ‚àà ùì§ Œ±, (set.prod {y : Œ± | (a, y) ‚àà s} {x : Œ± | (x, b) ‚àà s} ‚à© t).nonempty) :
  begin
    rw [lift'_inf_principal_eq, lift'_ne_bot_iff],
    exact monotone_inter (monotone_prod monotone_preimage monotone_preimage) monotone_const
  end
  ... ‚Üî (‚àÄ s ‚àà ùì§ Œ±, (a, b) ‚àà comp_rel s (comp_rel t s)) :
    forall_congr $ assume s, forall_congr $ assume hs,
    ‚ü®assume ‚ü®‚ü®x, y‚ü©, ‚ü®‚ü®hx, hy‚ü©, hxyt‚ü©‚ü©, ‚ü®x, hx, y, hxyt, hy‚ü©,
      assume ‚ü®x, hx, y, hxyt, hy‚ü©, ‚ü®‚ü®x, y‚ü©, ‚ü®‚ü®hx, hy‚ü©, hxyt‚ü©‚ü©‚ü©
  ... ‚Üî _ : by simp

lemma uniformity_eq_uniformity_closure : ùì§ Œ± = (ùì§ Œ±).lift' closure :=
le_antisymm
  (le_infi $ assume s, le_infi $ assume hs, by simp; filter_upwards [hs] subset_closure)
  (calc (ùì§ Œ±).lift' closure ‚â§ (ùì§ Œ±).lift' (Œªd, comp_rel d (comp_rel d d)) :
      lift'_mono' (by intros s hs; rw [closure_eq_inter_uniformity]; exact bInter_subset_of_mem hs)
    ... ‚â§ (ùì§ Œ±) : comp_le_uniformity3)

lemma uniformity_eq_uniformity_interior : ùì§ Œ± = (ùì§ Œ±).lift' interior :=
le_antisymm
  (le_infi $ assume d, le_infi $ assume hd,
    let ‚ü®s, hs, hs_comp‚ü© := (mem_lift'_sets $
      monotone_comp_rel monotone_id $ monotone_comp_rel monotone_id monotone_id).mp (comp_le_uniformity3 hd) in
    let ‚ü®t, ht, hst, ht_comp‚ü© := nhdset_of_mem_uniformity s hs in
    have s ‚äÜ interior d, from
      calc s ‚äÜ t : hst
       ... ‚äÜ interior d : (subset_interior_iff_subset_of_open ht).mpr $
        assume x, assume : x ‚àà t, let ‚ü®x, y, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := ht_comp this in hs_comp ‚ü®x, h‚ÇÅ, y, h‚ÇÇ, h‚ÇÉ‚ü©,
    have interior d ‚àà ùì§ Œ±, by filter_upwards [hs] this,
    by simp [this])
  (assume s hs, ((ùì§ Œ±).lift' interior).sets_of_superset (mem_lift' hs) interior_subset)

lemma interior_mem_uniformity {s : set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) :
  interior s ‚àà ùì§ Œ± :=
by rw [uniformity_eq_uniformity_interior]; exact mem_lift' hs

lemma mem_uniformity_is_closed {s : set (Œ±√óŒ±)} (h : s ‚àà ùì§ Œ±) :
  ‚àÉt ‚àà ùì§ Œ±, is_closed t ‚àß t ‚äÜ s :=
have s ‚àà (ùì§ Œ±).lift' closure, by rwa [uniformity_eq_uniformity_closure] at h,
have ‚àÉ t ‚àà ùì§ Œ±, closure t ‚äÜ s,
  by rwa [mem_lift'_sets] at this; apply closure_mono,
let ‚ü®t, ht, hst‚ü© := this in
‚ü®closure t, (ùì§ Œ±).sets_of_superset ht subset_closure, is_closed_closure, hst‚ü©

/-! ### Uniform continuity -/

/-- A function `f : Œ± ‚Üí Œ≤` is *uniformly continuous* if `(f x, f y)` tends to the diagonal
as `(x, y)` tends to the diagonal. In other words, if `x` is sufficiently close to `y`, then
`f x` is close to `f y` no matter where `x` and `y` are located in `Œ±`. -/
def uniform_continuous [uniform_space Œ≤] (f : Œ± ‚Üí Œ≤) :=
tendsto (Œªx:Œ±√óŒ±, (f x.1, f x.2)) (ùì§ Œ±) (ùì§ Œ≤)

theorem uniform_continuous_def [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  uniform_continuous f ‚Üî ‚àÄ r ‚àà ùì§ Œ≤,
    {x : Œ± √ó Œ± | (f x.1, f x.2) ‚àà r} ‚àà ùì§ Œ± :=
iff.rfl

lemma uniform_continuous_of_const [uniform_space Œ≤] {c : Œ± ‚Üí Œ≤} (h : ‚àÄa b, c a = c b) :
  uniform_continuous c :=
have (Œª (x : Œ± √ó Œ±), (c (x.fst), c (x.snd))) ‚Åª¬π' id_rel = univ, from
  eq_univ_iff_forall.2 $ assume ‚ü®a, b‚ü©, h a b,
le_trans (map_le_iff_le_comap.2 $ by simp [comap_principal, this, univ_mem_sets]) refl_le_uniformity

lemma uniform_continuous_id : uniform_continuous (@id Œ±) :=
by simp [uniform_continuous]; exact tendsto_id

lemma uniform_continuous_const [uniform_space Œ≤] {b : Œ≤} : uniform_continuous (Œªa:Œ±, b) :=
uniform_continuous_of_const $ Œª _ _, rfl

lemma uniform_continuous.comp [uniform_space Œ≤] [uniform_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}
  (hg : uniform_continuous g) (hf : uniform_continuous f) : uniform_continuous (g ‚àò f) :=
hg.comp hf

lemma filter.has_basis.uniform_continuous_iff [uniform_space Œ≤] {p : Œ≥ ‚Üí Prop} {s : Œ≥ ‚Üí set (Œ±√óŒ±)}
  (ha : (ùì§ Œ±).has_basis p s) {q : Œ¥ ‚Üí Prop} {t : Œ¥ ‚Üí set (Œ≤√óŒ≤)} (hb : (ùì§ Œ≤).has_basis q t)
  {f : Œ± ‚Üí Œ≤} :
  uniform_continuous f ‚Üî ‚àÄ i (hi : q i), ‚àÉ j (hj : p j), ‚àÄ x y, (x, y) ‚àà s j ‚Üí (f x, f y) ‚àà t i :=
(ha.tendsto_iff hb).trans $ by simp only [prod.forall]

end uniform_space
end

open_locale uniformity

section constructions
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œ¥ : Type*} {Œπ : Sort*}

instance : partial_order (uniform_space Œ±) :=
{ le          := Œªt s, t.uniformity ‚â§ s.uniformity,
  le_antisymm := assume t s h‚ÇÅ h‚ÇÇ, uniform_space_eq $ le_antisymm h‚ÇÅ h‚ÇÇ,
  le_refl     := assume t, le_refl _,
  le_trans    := assume a b c h‚ÇÅ h‚ÇÇ, le_trans h‚ÇÅ h‚ÇÇ }

instance : has_Inf (uniform_space Œ±) :=
‚ü®assume s, uniform_space.of_core {
  uniformity := (‚®Öu‚ààs, @uniformity Œ± u),
  refl       := le_infi $ assume u, le_infi $ assume hu, u.refl,
  symm       := le_infi $ assume u, le_infi $ assume hu,
    le_trans (map_mono $ infi_le_of_le _ $ infi_le _ hu) u.symm,
  comp       := le_infi $ assume u, le_infi $ assume hu,
    le_trans (lift'_mono (infi_le_of_le _ $ infi_le _ hu) $ le_refl _) u.comp }‚ü©

private lemma Inf_le {tt : set (uniform_space Œ±)} {t : uniform_space Œ±} (h : t ‚àà tt) :
  Inf tt ‚â§ t :=
show (‚®Öu‚ààtt, @uniformity Œ± u) ‚â§ t.uniformity,
  from infi_le_of_le t $ infi_le _ h

private lemma le_Inf {tt : set (uniform_space Œ±)} {t : uniform_space Œ±} (h : ‚àÄt'‚ààtt, t ‚â§ t') :
  t ‚â§ Inf tt :=
show t.uniformity ‚â§ (‚®Öu‚ààtt, @uniformity Œ± u),
  from le_infi $ assume t', le_infi $ assume ht', h t' ht'

instance : has_top (uniform_space Œ±) :=
‚ü®uniform_space.of_core { uniformity := ‚ä§, refl := le_top, symm := le_top, comp := le_top }‚ü©

instance : has_bot (uniform_space Œ±) :=
‚ü®{ to_topological_space := ‚ä•,
  uniformity  := principal id_rel,
  refl        := le_refl _,
  symm        := by simp [tendsto]; apply subset.refl,
  comp        :=
  begin
    rw [lift'_principal], {simp},
    exact monotone_comp_rel monotone_id monotone_id
  end,
  is_open_uniformity :=
    assume s, by simp [is_open_fold, subset_def, id_rel] {contextual := tt } } ‚ü©

instance : complete_lattice (uniform_space Œ±) :=
{ sup           := Œªa b, Inf {x | a ‚â§ x ‚àß b ‚â§ x},
  le_sup_left   := Œª a b, le_Inf (Œª _ ‚ü®h, _‚ü©, h),
  le_sup_right  := Œª a b, le_Inf (Œª _ ‚ü®_, h‚ü©, h),
  sup_le        := Œª a b c h‚ÇÅ h‚ÇÇ, Inf_le ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
  inf           := Œª a b, Inf {a, b},
  le_inf        := Œª a b c h‚ÇÅ h‚ÇÇ, le_Inf (Œª u h,
                     by { cases h, exact h.symm ‚ñ∏ h‚ÇÇ, exact (mem_singleton_iff.1 h).symm ‚ñ∏ h‚ÇÅ }),
  inf_le_left   := Œª a b, Inf_le (by simp),
  inf_le_right  := Œª a b, Inf_le (by simp),
  top           := ‚ä§,
  le_top        := Œª a, show a.uniformity ‚â§ ‚ä§, from le_top,
  bot           := ‚ä•,
  bot_le        := Œª u, u.refl,
  Sup           := Œª tt, Inf {t | ‚àÄ t' ‚àà tt, t' ‚â§ t},
  le_Sup        := Œª s u h, le_Inf (Œª u' h', h' u h),
  Sup_le        := Œª s u h, Inf_le h,
  Inf           := Inf,
  le_Inf        := Œª s a hs, le_Inf hs,
  Inf_le        := Œª s a ha, Inf_le ha,
  ..uniform_space.partial_order }

lemma infi_uniformity {Œπ : Sort*} {u : Œπ ‚Üí uniform_space Œ±} :
  (infi u).uniformity = (‚®Öi, (u i).uniformity) :=
show (‚®Öa (h : ‚àÉi:Œπ, u i = a), a.uniformity) = _, from
le_antisymm
  (le_infi $ assume i, infi_le_of_le (u i) $ infi_le _ ‚ü®i, rfl‚ü©)
  (le_infi $ assume a, le_infi $ assume ‚ü®i, (ha : u i = a)‚ü©, ha ‚ñ∏ infi_le _ _)

lemma inf_uniformity {u v : uniform_space Œ±} :
  (u ‚äì v).uniformity = u.uniformity ‚äì v.uniformity :=
have (u ‚äì v) = (‚®Öi (h : i = u ‚à® i = v), i), by simp [infi_or, infi_inf_eq],
calc (u ‚äì v).uniformity = ((‚®Öi (h : i = u ‚à® i = v), i) : uniform_space Œ±).uniformity : by rw [this]
  ... = _ : by simp [infi_uniformity, infi_or, infi_inf_eq]

instance inhabited_uniform_space : inhabited (uniform_space Œ±) := ‚ü®‚ä•‚ü©
instance inhabited_uniform_space_core : inhabited (uniform_space.core Œ±) :=
‚ü®@uniform_space.to_core _ (default _)‚ü©

/-- Given `f : Œ± ‚Üí Œ≤` and a uniformity `u` on `Œ≤`, the inverse image of `u` under `f`
  is the inverse image in the filter sense of the induced function `Œ± √ó Œ± ‚Üí Œ≤ √ó Œ≤`. -/
def uniform_space.comap (f : Œ± ‚Üí Œ≤) (u : uniform_space Œ≤) : uniform_space Œ± :=
{ uniformity := u.uniformity.comap (Œªp:Œ±√óŒ±, (f p.1, f p.2)),
  to_topological_space := u.to_topological_space.induced f,
  refl := le_trans (by simp; exact assume ‚ü®a, b‚ü© (h : a = b), h ‚ñ∏ rfl) (comap_mono u.refl),
  symm := by simp [tendsto_comap_iff, prod.swap, (‚àò)]; exact tendsto_swap_uniformity.comp tendsto_comap,
  comp := le_trans
    begin
      rw [comap_lift'_eq, comap_lift'_eq2],
      exact (lift'_mono' $ assume s hs ‚ü®a‚ÇÅ, a‚ÇÇ‚ü© ‚ü®x, h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®f x, h‚ÇÅ, h‚ÇÇ‚ü©),
      repeat { exact monotone_comp_rel monotone_id monotone_id }
    end
    (comap_mono u.comp),
  is_open_uniformity := Œª s, begin
    change (@is_open Œ± (u.to_topological_space.induced f) s ‚Üî _),
    simp [is_open_iff_nhds, nhds_induced, mem_nhds_uniformity_iff, filter.comap, and_comm],
    refine ball_congr (Œª x hx, ‚ü®_, _‚ü©),
    { rintro ‚ü®t, hts, ht‚ü©, refine ‚ü®_, ht, _‚ü©,
      rintro ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© h rfl, exact hts (h rfl) },
    { rintro ‚ü®t, ht, hts‚ü©,
      exact ‚ü®{y | (f x, y) ‚àà t}, Œª y hy, @hts (x, y) hy rfl,
        mem_nhds_uniformity_iff.1 $ mem_nhds_left _ ht‚ü© }
  end }

lemma uniform_space_comap_id {Œ± : Type*} : uniform_space.comap (id : Œ± ‚Üí Œ±) = id :=
by ext u ; dsimp [uniform_space.comap] ; rw [prod.id_prod, filter.comap_id]

lemma uniform_space.comap_comap_comp {Œ± Œ≤ Œ≥} [uŒ≥ : uniform_space Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} :
  uniform_space.comap (g ‚àò f) uŒ≥ = uniform_space.comap f (uniform_space.comap g uŒ≥) :=
by ext ; dsimp [uniform_space.comap] ; rw filter.comap_comap_comp

lemma uniform_continuous_iff {Œ± Œ≤} [uŒ± : uniform_space Œ±] [uŒ≤ : uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  uniform_continuous f ‚Üî uŒ± ‚â§ uŒ≤.comap f :=
filter.map_le_iff_le_comap

lemma uniform_continuous_comap {f : Œ± ‚Üí Œ≤} [u : uniform_space Œ≤] :
  @uniform_continuous Œ± Œ≤ (uniform_space.comap f u) u f :=
tendsto_comap

theorem to_topological_space_comap {f : Œ± ‚Üí Œ≤} {u : uniform_space Œ≤} :
  @uniform_space.to_topological_space _ (uniform_space.comap f u) =
  topological_space.induced f (@uniform_space.to_topological_space Œ≤ u) := rfl

lemma uniform_continuous_comap' {f : Œ≥ ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} [v : uniform_space Œ≤] [u : uniform_space Œ±]
  (h : uniform_continuous (f ‚àò g)) : @uniform_continuous Œ± Œ≥ u (uniform_space.comap f v) g :=
tendsto_comap_iff.2 h

lemma to_topological_space_mono {u‚ÇÅ u‚ÇÇ : uniform_space Œ±} (h : u‚ÇÅ ‚â§ u‚ÇÇ) :
  @uniform_space.to_topological_space _ u‚ÇÅ ‚â§ @uniform_space.to_topological_space _ u‚ÇÇ :=
le_of_nhds_le_nhds $ assume a,
  by rw [@nhds_eq_uniformity Œ± u‚ÇÅ a, @nhds_eq_uniformity Œ± u‚ÇÇ a]; exact (lift'_mono h $ le_refl _)

lemma uniform_continuous.continuous [uniform_space Œ±] [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤}
  (hf : uniform_continuous f) : continuous f :=
continuous_iff_le_induced.mpr $ to_topological_space_mono $ uniform_continuous_iff.1 hf

lemma to_topological_space_bot : @uniform_space.to_topological_space Œ± ‚ä• = ‚ä• := rfl

lemma to_topological_space_top : @uniform_space.to_topological_space Œ± ‚ä§ = ‚ä§ :=
top_unique $ assume s hs, s.eq_empty_or_nonempty.elim
  (assume : s = ‚àÖ, this.symm ‚ñ∏ @is_open_empty _ ‚ä§)
  (assume  ‚ü®x, hx‚ü©,
    have s = univ, from top_unique $ assume y hy, hs x hx (x, y) rfl,
    this.symm ‚ñ∏ @is_open_univ _ ‚ä§)

lemma to_topological_space_infi {Œπ : Sort*} {u : Œπ ‚Üí uniform_space Œ±} :
  (infi u).to_topological_space = ‚®Öi, (u i).to_topological_space :=
classical.by_cases
  (assume h : nonempty Œπ,
    eq_of_nhds_eq_nhds $ assume a,
    begin
      rw [nhds_infi, nhds_eq_uniformity],
      change (infi u).uniformity.lift' (preimage $ prod.mk a) = _,
      begin
        rw [infi_uniformity, lift'_infi],
        exact (congr_arg _ $ funext $ assume i, (@nhds_eq_uniformity Œ± (u i) a).symm),
        exact h,
        exact assume a b, rfl
      end
    end)
  (assume : ¬¨ nonempty Œπ,
    le_antisymm
      (le_infi $ assume i, to_topological_space_mono $ infi_le _ _)
      (have infi u = ‚ä§, from top_unique $ le_infi $ assume i, (this ‚ü®i‚ü©).elim,
        have @uniform_space.to_topological_space _ (infi u) = ‚ä§,
          from this.symm ‚ñ∏ to_topological_space_top,
        this.symm ‚ñ∏ le_top))

lemma to_topological_space_Inf {s : set (uniform_space Œ±)} :
  (Inf s).to_topological_space = (‚®Öi‚ààs, @uniform_space.to_topological_space Œ± i) :=
begin
  rw [Inf_eq_infi, to_topological_space_infi],
  apply congr rfl,
  funext x,
  exact to_topological_space_infi
end

lemma to_topological_space_inf {u v : uniform_space Œ±} :
  (u ‚äì v).to_topological_space = u.to_topological_space ‚äì v.to_topological_space :=
by rw [to_topological_space_Inf, infi_pair]

instance : uniform_space empty := ‚ä•
instance : uniform_space unit := ‚ä•
instance : uniform_space bool := ‚ä•
instance : uniform_space ‚Ñï := ‚ä•
instance : uniform_space ‚Ñ§ := ‚ä•

instance {p : Œ± ‚Üí Prop} [t : uniform_space Œ±] : uniform_space (subtype p) :=
uniform_space.comap subtype.val t

lemma uniformity_subtype {p : Œ± ‚Üí Prop} [t : uniform_space Œ±] :
  ùì§ (subtype p) = comap (Œªq:subtype p √ó subtype p, (q.1.1, q.2.1)) (ùì§ Œ±) :=
rfl

lemma uniform_continuous_subtype_val {p : Œ± ‚Üí Prop} [uniform_space Œ±] :
  uniform_continuous (subtype.val : {a : Œ± // p a} ‚Üí Œ±) :=
uniform_continuous_comap

lemma uniform_continuous_subtype_mk {p : Œ± ‚Üí Prop} [uniform_space Œ±] [uniform_space Œ≤]
  {f : Œ≤ ‚Üí Œ±} (hf : uniform_continuous f) (h : ‚àÄx, p (f x)) :
  uniform_continuous (Œªx, ‚ü®f x, h x‚ü© : Œ≤ ‚Üí subtype p) :=
uniform_continuous_comap' hf

lemma tendsto_of_uniform_continuous_subtype
  [uniform_space Œ±] [uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±}
  (hf : uniform_continuous (Œªx:s, f x.val)) (ha : s ‚àà ùìù a) :
  tendsto f (ùìù a) (ùìù (f a)) :=
by rw [(@map_nhds_subtype_val_eq Œ± _ s a (mem_of_nhds ha) ha).symm]; exact
tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)


section prod

/- a similar product space is possible on the function space (uniformity of pointwise convergence),
  but we want to have the uniformity of uniform convergence on function spaces -/
instance [u‚ÇÅ : uniform_space Œ±] [u‚ÇÇ : uniform_space Œ≤] : uniform_space (Œ± √ó Œ≤) :=
uniform_space.of_core_eq
  (u‚ÇÅ.comap prod.fst ‚äì u‚ÇÇ.comap prod.snd).to_core
  prod.topological_space
  (calc prod.topological_space = (u‚ÇÅ.comap prod.fst ‚äì u‚ÇÇ.comap prod.snd).to_topological_space :
      by rw [to_topological_space_inf, to_topological_space_comap, to_topological_space_comap]; refl
    ... = _ : by rw [uniform_space.to_core_to_topological_space])

theorem uniformity_prod [uniform_space Œ±] [uniform_space Œ≤] : ùì§ (Œ± √ó Œ≤) =
  (ùì§ Œ±).comap (Œªp:(Œ± √ó Œ≤) √ó Œ± √ó Œ≤, (p.1.1, p.2.1)) ‚äì
  (ùì§ Œ≤).comap (Œªp:(Œ± √ó Œ≤) √ó Œ± √ó Œ≤, (p.1.2, p.2.2)) :=
inf_uniformity

lemma uniformity_prod_eq_prod [uniform_space Œ±] [uniform_space Œ≤] :
  ùì§ (Œ±√óŒ≤) =
    map (Œªp:(Œ±√óŒ±)√ó(Œ≤√óŒ≤), ((p.1.1, p.2.1), (p.1.2, p.2.2))) (filter.prod (ùì§ Œ±) (ùì§ Œ≤)) :=
have map (Œªp:(Œ±√óŒ±)√ó(Œ≤√óŒ≤), ((p.1.1, p.2.1), (p.1.2, p.2.2))) =
  comap (Œªp:(Œ±√óŒ≤)√ó(Œ±√óŒ≤), ((p.1.1, p.2.1), (p.1.2, p.2.2))),
  from funext $ assume f, map_eq_comap_of_inverse
    (funext $ assume ‚ü®‚ü®_, _‚ü©, ‚ü®_, _‚ü©‚ü©, rfl) (funext $ assume ‚ü®‚ü®_, _‚ü©, ‚ü®_, _‚ü©‚ü©, rfl),
by rw [this, uniformity_prod, filter.prod, comap_inf, comap_comap_comp, comap_comap_comp]

lemma mem_map_sets_iff' {Œ± : Type*} {Œ≤ : Type*} {f : filter Œ±} {m : Œ± ‚Üí Œ≤} {t : set Œ≤} :
  t ‚àà (map m f).sets ‚Üî (‚àÉs‚ààf, m '' s ‚äÜ t) :=
mem_map_sets_iff

lemma mem_uniformity_of_uniform_continuous_invariant [uniform_space Œ±] {s:set (Œ±√óŒ±)} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
  (hf : uniform_continuous (Œªp:Œ±√óŒ±, f p.1 p.2)) (hs : s ‚àà ùì§ Œ±) :
  ‚àÉu‚ààùì§ Œ±, ‚àÄa b c, (a, b) ‚àà u ‚Üí (f a c, f b c) ‚àà s :=
begin
  rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff, (‚àò)] at hf,
  rcases mem_map_sets_iff'.1 (hf hs) with ‚ü®t, ht, hts‚ü©, clear hf,
  rcases mem_prod_iff.1 ht with ‚ü®u, hu, v, hv, huvt‚ü©, clear ht,
  refine ‚ü®u, hu, assume a b c hab, hts $ (mem_image _ _ _).2 ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®c, c‚ü©‚ü©, huvt ‚ü®_, _‚ü©, _‚ü©‚ü©,
  exact hab,
  exact refl_mem_uniformity hv,
  refl
end

lemma mem_uniform_prod [t‚ÇÅ : uniform_space Œ±] [t‚ÇÇ : uniform_space Œ≤] {a : set (Œ± √ó Œ±)} {b : set (Œ≤ √ó Œ≤)}
  (ha : a ‚àà ùì§ Œ±) (hb : b ‚àà ùì§ Œ≤) :
  {p:(Œ±√óŒ≤)√ó(Œ±√óŒ≤) | (p.1.1, p.2.1) ‚àà a ‚àß (p.1.2, p.2.2) ‚àà b } ‚àà (@uniformity (Œ± √ó Œ≤) _) :=
by rw [uniformity_prod]; exact inter_mem_inf_sets (preimage_mem_comap ha) (preimage_mem_comap hb)

lemma tendsto_prod_uniformity_fst [uniform_space Œ±] [uniform_space Œ≤] :
  tendsto (Œªp:(Œ±√óŒ≤)√ó(Œ±√óŒ≤), (p.1.1, p.2.1)) (ùì§ (Œ± √ó Œ≤)) (ùì§ Œ±) :=
le_trans (map_mono (@inf_le_left (uniform_space (Œ±√óŒ≤)) _ _ _)) map_comap_le

lemma tendsto_prod_uniformity_snd [uniform_space Œ±] [uniform_space Œ≤] :
  tendsto (Œªp:(Œ±√óŒ≤)√ó(Œ±√óŒ≤), (p.1.2, p.2.2)) (ùì§ (Œ± √ó Œ≤)) (ùì§ Œ≤) :=
le_trans (map_mono (@inf_le_right (uniform_space (Œ±√óŒ≤)) _ _ _)) map_comap_le

lemma uniform_continuous_fst [uniform_space Œ±] [uniform_space Œ≤] : uniform_continuous (Œªp:Œ±√óŒ≤, p.1) :=
tendsto_prod_uniformity_fst

lemma uniform_continuous_snd [uniform_space Œ±] [uniform_space Œ≤] : uniform_continuous (Œªp:Œ±√óŒ≤, p.2) :=
tendsto_prod_uniformity_snd

variables [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥]
lemma uniform_continuous.prod_mk
  {f‚ÇÅ : Œ± ‚Üí Œ≤} {f‚ÇÇ : Œ± ‚Üí Œ≥} (h‚ÇÅ : uniform_continuous f‚ÇÅ) (h‚ÇÇ : uniform_continuous f‚ÇÇ) :
  uniform_continuous (Œªa, (f‚ÇÅ a, f‚ÇÇ a)) :=
by rw [uniform_continuous, uniformity_prod]; exact
tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©

lemma uniform_continuous.prod_mk_left {f : Œ± √ó Œ≤ ‚Üí Œ≥} (h : uniform_continuous f) (b) :
  uniform_continuous (Œª a, f (a,b)) :=
h.comp (uniform_continuous_id.prod_mk uniform_continuous_const)

lemma uniform_continuous.prod_mk_right {f : Œ± √ó Œ≤ ‚Üí Œ≥} (h : uniform_continuous f) (a) :
  uniform_continuous (Œª b, f (a,b)) :=
h.comp (uniform_continuous_const.prod_mk  uniform_continuous_id)

lemma to_topological_space_prod {Œ±} {Œ≤} [u : uniform_space Œ±] [v : uniform_space Œ≤] :
  @uniform_space.to_topological_space (Œ± √ó Œ≤) prod.uniform_space =
    @prod.topological_space Œ± Œ≤ u.to_topological_space v.to_topological_space := rfl

end prod

section
open uniform_space function
variables [uniform_space Œ±] [uniform_space Œ≤] [uniform_space Œ≥] [uniform_space Œ¥]

local notation f `‚àò‚ÇÇ` g := function.bicompr f g

def uniform_continuous‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) := uniform_continuous (uncurry' f)

lemma uniform_continuous‚ÇÇ_def (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) : uniform_continuous‚ÇÇ f ‚Üî uniform_continuous (uncurry' f) := iff.rfl

lemma uniform_continuous‚ÇÇ_curry (f : Œ± √ó Œ≤ ‚Üí Œ≥) : uniform_continuous‚ÇÇ (function.curry f) ‚Üî uniform_continuous f :=
by rw  [‚Üêuncurry'_curry f] {occs := occurrences.pos [2]} ; refl

lemma uniform_continuous‚ÇÇ.comp {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ≥ ‚Üí Œ¥}
  (hg : uniform_continuous g) (hf : uniform_continuous‚ÇÇ f) :
  uniform_continuous‚ÇÇ (g ‚àò‚ÇÇ f) :=
hg.comp hf

end

lemma to_topological_space_subtype [u : uniform_space Œ±] {p : Œ± ‚Üí Prop} :
  @uniform_space.to_topological_space (subtype p) subtype.uniform_space =
    @subtype.topological_space Œ± p u.to_topological_space := rfl

section sum
variables [uniform_space Œ±] [uniform_space Œ≤]
open sum

/-- Uniformity on a disjoint union. Entourages of the diagonal in the union are obtained
by taking independently an entourage of the diagonal in the first part, and an entourage of
the diagonal in the second part. -/
def uniform_space.core.sum : uniform_space.core (Œ± ‚äï Œ≤) :=
uniform_space.core.mk'
  (map (Œª p : Œ± √ó Œ±, (inl p.1, inl p.2)) (ùì§ Œ±) ‚äî map (Œª p : Œ≤ √ó Œ≤, (inr p.1, inr p.2)) (ùì§ Œ≤))
  (Œª r ‚ü®H‚ÇÅ, H‚ÇÇ‚ü© x, by cases x; [apply refl_mem_uniformity H‚ÇÅ, apply refl_mem_uniformity H‚ÇÇ])
  (Œª r ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©, ‚ü®symm_le_uniformity H‚ÇÅ, symm_le_uniformity H‚ÇÇ‚ü©)
  (Œª r ‚ü®HrŒ±, HrŒ≤‚ü©, begin
    rcases comp_mem_uniformity_sets HrŒ± with ‚ü®tŒ±, htŒ±, HtŒ±‚ü©,
    rcases comp_mem_uniformity_sets HrŒ≤ with ‚ü®tŒ≤, htŒ≤, HtŒ≤‚ü©,
    refine ‚ü®_,
      ‚ü®mem_map_sets_iff.2 ‚ü®tŒ±, htŒ±, subset_union_left _ _‚ü©,
       mem_map_sets_iff.2 ‚ü®tŒ≤, htŒ≤, subset_union_right _ _‚ü©‚ü©, _‚ü©,
    rintros ‚ü®_, _‚ü© ‚ü®z, ‚ü®‚ü®a, b‚ü©, hab, ‚ü®‚ü©‚ü© | ‚ü®‚ü®a, b‚ü©, hab, ‚ü®‚ü©‚ü©,
                       ‚ü®‚ü®_, c‚ü©, hbc, ‚ü®‚ü©‚ü© | ‚ü®‚ü®_, c‚ü©, hbc, ‚ü®‚ü©‚ü©‚ü©,
    { have A : (a, c) ‚àà comp_rel tŒ± tŒ± := ‚ü®b, hab, hbc‚ü©,
      exact HtŒ± A },
    { have A : (a, c) ‚àà comp_rel tŒ≤ tŒ≤ := ‚ü®b, hab, hbc‚ü©,
      exact HtŒ≤ A }
  end)

/-- The union of an entourage of the diagonal in each set of a disjoint union is again an entourage of the diagonal. -/
lemma union_mem_uniformity_sum
  {a : set (Œ± √ó Œ±)} (ha : a ‚àà ùì§ Œ±) {b : set (Œ≤ √ó Œ≤)} (hb : b ‚àà ùì§ Œ≤) :
  ((Œª p : (Œ± √ó Œ±), (inl p.1, inl p.2)) '' a ‚à™ (Œª p : (Œ≤ √ó Œ≤), (inr p.1, inr p.2)) '' b) ‚àà (@uniform_space.core.sum Œ± Œ≤ _ _).uniformity :=
‚ü®mem_map_sets_iff.2 ‚ü®_, ha, subset_union_left _ _‚ü©, mem_map_sets_iff.2 ‚ü®_, hb, subset_union_right _ _‚ü©‚ü©

/- To prove that the topology defined by the uniform structure on the disjoint union coincides with
the disjoint union topology, we need two lemmas saying that open sets can be characterized by
the uniform structure -/
lemma uniformity_sum_of_open_aux {s : set (Œ± ‚äï Œ≤)} (hs : is_open s) {x : Œ± ‚äï Œ≤} (xs : x ‚àà s) :
  { p : ((Œ± ‚äï Œ≤) √ó (Œ± ‚äï Œ≤)) | p.1 = x ‚Üí p.2 ‚àà s } ‚àà (@uniform_space.core.sum Œ± Œ≤ _ _).uniformity :=
begin
  cases x,
  { refine mem_sets_of_superset
      (union_mem_uniformity_sum (mem_nhds_uniformity_iff.1 (mem_nhds_sets hs.1 xs)) univ_mem_sets)
      (union_subset _ _);
    rintro _ ‚ü®‚ü®_, b‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©,
    exact h rfl },
  { refine mem_sets_of_superset
      (union_mem_uniformity_sum univ_mem_sets (mem_nhds_uniformity_iff.1 (mem_nhds_sets hs.2 xs)))
      (union_subset _ _);
    rintro _ ‚ü®‚ü®a, _‚ü©, h, ‚ü®‚ü©‚ü© ‚ü®‚ü©,
    exact h rfl },
end

lemma open_of_uniformity_sum_aux {s : set (Œ± ‚äï Œ≤)}
  (hs : ‚àÄx ‚àà s, { p : ((Œ± ‚äï Œ≤) √ó (Œ± ‚äï Œ≤)) | p.1 = x ‚Üí p.2 ‚àà s } ‚àà (@uniform_space.core.sum Œ± Œ≤ _ _).uniformity) :
  is_open s :=
begin
  split,
  { refine (@is_open_iff_mem_nhds Œ± _ _).2 (Œª a ha, mem_nhds_uniformity_iff.2 _),
    rcases mem_map_sets_iff.1 (hs _ ha).1 with ‚ü®t, ht, st‚ü©,
    refine mem_sets_of_superset ht _,
    rintro p pt rfl, exact st ‚ü®_, pt, rfl‚ü© rfl },
  { refine (@is_open_iff_mem_nhds Œ≤ _ _).2 (Œª b hb, mem_nhds_uniformity_iff.2 _),
    rcases mem_map_sets_iff.1 (hs _ hb).2 with ‚ü®t, ht, st‚ü©,
    refine mem_sets_of_superset ht _,
    rintro p pt rfl, exact st ‚ü®_, pt, rfl‚ü© rfl }
end

/- We can now define the uniform structure on the disjoint union -/
instance sum.uniform_space : uniform_space (Œ± ‚äï Œ≤) :=
{ to_core := uniform_space.core.sum,
  is_open_uniformity := Œª s, ‚ü®uniformity_sum_of_open_aux, open_of_uniformity_sum_aux‚ü© }

lemma sum.uniformity : ùì§ (Œ± ‚äï Œ≤) =
    map (Œª p : Œ± √ó Œ±, (inl p.1, inl p.2)) (ùì§ Œ±) ‚äî
    map (Œª p : Œ≤ √ó Œ≤, (inr p.1, inr p.2)) (ùì§ Œ≤) := rfl

end sum

end constructions

lemma lebesgue_number_lemma {Œ± : Type u} [uniform_space Œ±] {s : set Œ±} {Œπ} {c : Œπ ‚Üí set Œ±}
  (hs : compact s) (hc‚ÇÅ : ‚àÄ i, is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) :
  ‚àÉ n ‚àà ùì§ Œ±, ‚àÄ x ‚àà s, ‚àÉ i, {y | (x, y) ‚àà n} ‚äÜ c i :=
begin
  let u := Œª n, {x | ‚àÉ i (m ‚àà ùì§ Œ±), {y | (x, y) ‚àà comp_rel m n} ‚äÜ c i},
  have hu‚ÇÅ : ‚àÄ n ‚àà ùì§ Œ±, is_open (u n),
  { refine Œª n hn, is_open_uniformity.2 _,
    rintro x ‚ü®i, m, hm, h‚ü©,
    rcases comp_mem_uniformity_sets hm with ‚ü®m', hm', mm'‚ü©,
    apply (ùì§ Œ±).sets_of_superset hm',
    rintros ‚ü®x, y‚ü© hp rfl,
    refine ‚ü®i, m', hm', Œª z hz, h (monotone_comp_rel monotone_id monotone_const mm' _)‚ü©,
    dsimp at hz ‚ä¢, rw comp_rel_assoc,
    exact ‚ü®y, hp, hz‚ü© },
  have hu‚ÇÇ : s ‚äÜ ‚ãÉ n ‚àà ùì§ Œ±, u n,
  { intros x hx,
    rcases mem_Union.1 (hc‚ÇÇ hx) with ‚ü®i, h‚ü©,
    rcases comp_mem_uniformity_sets (is_open_uniformity.1 (hc‚ÇÅ i) x h) with ‚ü®m', hm', mm'‚ü©,
    exact mem_bUnion hm' ‚ü®i, _, hm', Œª y hy, mm' hy rfl‚ü© },
  rcases hs.elim_finite_subcover_image hu‚ÇÅ hu‚ÇÇ with ‚ü®b, bu, b_fin, b_cover‚ü©,
  refine ‚ü®_, Inter_mem_sets b_fin bu, Œª x hx, _‚ü©,
  rcases mem_bUnion_iff.1 (b_cover hx) with ‚ü®n, bn, i, m, hm, h‚ü©,
  refine ‚ü®i, Œª y hy, h _‚ü©,
  exact prod_mk_mem_comp_rel (refl_mem_uniformity hm) (bInter_subset_of_mem bn hy)
end

lemma lebesgue_number_lemma_sUnion {Œ± : Type u} [uniform_space Œ±] {s : set Œ±} {c : set (set Œ±)}
  (hs : compact s) (hc‚ÇÅ : ‚àÄ t ‚àà c, is_open t) (hc‚ÇÇ : s ‚äÜ ‚ãÉ‚ÇÄ c) :
  ‚àÉ n ‚àà ùì§ Œ±, ‚àÄ x ‚àà s, ‚àÉ t ‚àà c, ‚àÄ y, (x, y) ‚àà n ‚Üí y ‚àà t :=
by rw sUnion_eq_Union at hc‚ÇÇ;
   simpa using lebesgue_number_lemma hs (by simpa) hc‚ÇÇ
