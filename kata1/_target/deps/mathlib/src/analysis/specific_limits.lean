/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl

A collection of specific limit computations.
-/
import analysis.normed_space.basic algebra.geom_sum
import topology.instances.ennreal

noncomputable theory
open_locale classical topological_space

open classical function lattice filter finset metric

variables {Œ± : Type*} {Œ≤ : Type*} {Œπ : Type*}

lemma tendsto_norm_at_top_at_top : tendsto (norm : ‚Ñù ‚Üí ‚Ñù) at_top at_top :=
tendsto_abs_at_top_at_top

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. The archimedean assumption is convenient to get a
statement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is
given in `tendsto_at_top_mul_left'`). -/
lemma tendsto_at_top_mul_left [decidable_linear_ordered_semiring Œ±] [archimedean Œ±]
  {l : filter Œ≤} {r : Œ±} (hr : 0 < r) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f l at_top) :
  tendsto (Œªx, r * f x) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  obtain ‚ü®n, hn‚ü© : ‚àÉ (n : ‚Ñï), (1 : Œ±) ‚â§ n ‚Ä¢ r := archimedean.arch 1 hr,
  have hn' : 1 ‚â§ r * n, by rwa add_monoid.smul_eq_mul' at hn,
  filter_upwards [(tendsto_at_top _ _).1 hf (n * max b 0)],
  assume x hx,
  calc b ‚â§ 1 * max b 0 : by { rw [one_mul], exact le_max_left _ _ }
  ... ‚â§ (r * n) * max b 0 : mul_le_mul_of_nonneg_right hn' (le_max_right _ _)
  ... = r * (n * max b 0) : by rw [mul_assoc]
  ... ‚â§ r * f x : mul_le_mul_of_nonneg_left hx (le_of_lt hr)
end

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. The archimedean assumption is convenient to get a
statement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is
given in `tendsto_at_top_mul_right'`). -/
lemma tendsto_at_top_mul_right [decidable_linear_ordered_semiring Œ±] [archimedean Œ±]
  {l : filter Œ≤} {r : Œ±} (hr : 0 < r) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f l at_top) :
  tendsto (Œªx, f x * r) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  obtain ‚ü®n, hn‚ü© : ‚àÉ (n : ‚Ñï), (1 : Œ±) ‚â§ n ‚Ä¢ r := archimedean.arch 1 hr,
  have hn' : 1 ‚â§ (n : Œ±) * r, by rwa add_monoid.smul_eq_mul at hn,
  filter_upwards [(tendsto_at_top _ _).1 hf (max b 0 * n)],
  assume x hx,
  calc b ‚â§ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ }
  ... ‚â§ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _)
  ... = (max b 0 * n) * r : by rw [mul_assoc]
  ... ‚â§ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
end

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`tendsto_at_top_mul_left` instead. -/
lemma tendsto_at_top_mul_left' [linear_ordered_field Œ±]
  {l : filter Œ≤} {r : Œ±} (hr : 0 < r) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f l at_top) :
  tendsto (Œªx, r * f x) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  filter_upwards [(tendsto_at_top _ _).1 hf (b/r)],
  assume x hx,
  simpa [div_le_iff' hr] using hx
end

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`tendsto_at_top_mul_right` instead. -/
lemma tendsto_at_top_mul_right' [linear_ordered_field Œ±]
  {l : filter Œ≤} {r : Œ±} (hr : 0 < r) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f l at_top) :
  tendsto (Œªx, f x * r) l at_top :=
by simpa [mul_comm] using tendsto_at_top_mul_left' hr hf

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
lemma tendsto_at_top_div [linear_ordered_field Œ±]
  {l : filter Œ≤} {r : Œ±} (hr : 0 < r) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f l at_top) :
  tendsto (Œªx, f x / r) l at_top :=
tendsto_at_top_mul_right' (inv_pos hr) hf

/-- The function `x ‚Ü¶ x‚Åª¬π` tends to `+‚àû` on the right of `0`. -/
lemma tendsto_inv_zero_at_top [discrete_linear_ordered_field Œ±] [topological_space Œ±]
  [order_topology Œ±] : tendsto (Œªx:Œ±, x‚Åª¬π) (nhds_within (0 : Œ±) (set.Ioi 0)) at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  refine mem_nhds_within_Ioi_iff_exists_Ioo_subset.2 ‚ü®(max b 1)‚Åª¬π, by simp [zero_lt_one], Œªx hx, _‚ü©,
  calc b ‚â§ max b 1 : le_max_left _ _
  ... ‚â§ x‚Åª¬π : begin
    apply (le_inv _ hx.1).2 (le_of_lt hx.2),
    exact lt_of_lt_of_le zero_lt_one (le_max_right _ _)
  end
end

/-- The function `r ‚Ü¶ r‚Åª¬π` tends to `0` on the right as `r ‚Üí +‚àû`. -/
lemma tendsto_inv_at_top_zero' [discrete_linear_ordered_field Œ±] [topological_space Œ±]
  [order_topology Œ±] : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (nhds_within (0 : Œ±) (set.Ioi 0)) :=
begin
  assume s hs,
  rw mem_nhds_within_Ioi_iff_exists_Ioc_subset at hs,
  rcases hs with ‚ü®C, C0, hC‚ü©,
  change 0 < C at C0,
  refine filter.mem_map.2 (mem_sets_of_superset (mem_at_top C‚Åª¬π) (Œª x hx, hC _)),
  have : 0 < x, from lt_of_lt_of_le (inv_pos C0) hx,
  exact ‚ü®inv_pos this, (inv_le C0 this).1 hx‚ü©
end

lemma tendsto_inv_at_top_zero [discrete_linear_ordered_field Œ±] [topological_space Œ±]
  [order_topology Œ±] : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (ùìù 0) :=
tendsto_le_right inf_le_left tendsto_inv_at_top_zero'

lemma summable_of_absolute_convergence_real {f : ‚Ñï ‚Üí ‚Ñù} :
  (‚àÉr, tendsto (Œªn, (range n).sum (Œªi, abs (f i))) at_top (ùìù r)) ‚Üí summable f
| ‚ü®r, hr‚ü© :=
  begin
    refine summable_of_summable_norm ‚ü®r, (has_sum_iff_tendsto_nat_of_nonneg _ _).2 _‚ü©,
    exact assume i, norm_nonneg _,
    simpa only using hr
  end

lemma tendsto_pow_at_top_at_top_of_gt_1 {r : ‚Ñù} (h : 1 < r) :
  tendsto (Œªn:‚Ñï, r ^ n) at_top at_top :=
(tendsto_at_top_at_top _).2 $ assume p,
  let ‚ü®n, hn‚ü© := pow_unbounded_of_one_lt p h in
  ‚ü®n, Œª m hnm, le_of_lt $
    lt_of_lt_of_le hn (pow_le_pow (le_of_lt h) hnm)‚ü©

lemma lim_norm_zero' {ùïú : Type*} [normed_group ùïú] :
  tendsto (norm : ùïú ‚Üí ‚Ñù) (nhds_within 0 {x | x ‚â† 0}) (nhds_within 0 (set.Ioi 0)) :=
lim_norm_zero.inf $ tendsto_principal_principal.2 $ Œª x hx, (norm_pos_iff _).2 hx

lemma normed_field.tendsto_norm_inverse_nhds_within_0_at_top {ùïú : Type*} [normed_field ùïú] :
  tendsto (Œª x:ùïú, ‚à•x‚Åª¬π‚à•) (nhds_within 0 {x | x ‚â† 0}) at_top :=
(tendsto_inv_zero_at_top.comp lim_norm_zero').congr $ Œª x, (normed_field.norm_inv x).symm

lemma tendsto_pow_at_top_nhds_0_of_lt_1 {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) :
  tendsto (Œªn:‚Ñï, r^n) at_top (ùìù 0) :=
by_cases
  (assume : r = 0, (tendsto_add_at_top_iff_nat 1).mp $ by simp [pow_succ, this, tendsto_const_nhds])
  (assume : r ‚â† 0,
    have tendsto (Œªn, (r‚Åª¬π ^ n)‚Åª¬π) at_top (ùìù 0),
      from tendsto_inv_at_top_zero.comp
        (tendsto_pow_at_top_at_top_of_gt_1 $ one_lt_inv (lt_of_le_of_ne h‚ÇÅ this.symm) h‚ÇÇ),
    tendsto.congr' (univ_mem_sets' $ by simp *) this)

lemma nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 {r : nnreal} (hr : r < 1) :
  tendsto (Œª n:‚Ñï, r^n) at_top (ùìù 0) :=
nnreal.tendsto_coe.1 $ by simp only [nnreal.coe_pow, nnreal.coe_zero,
  tendsto_pow_at_top_nhds_0_of_lt_1 r.coe_nonneg hr]

lemma ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 {r : ennreal} (hr : r < 1) :
  tendsto (Œª n:‚Ñï, r^n) at_top (ùìù 0) :=
begin
  rcases ennreal.lt_iff_exists_coe.1 hr with ‚ü®r, rfl, hr'‚ü©,
  rw [‚Üê ennreal.coe_zero],
  norm_cast at *,
  apply nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 hr
end

lemma tendsto_pow_at_top_nhds_0_of_lt_1_normed_field {K : Type*} [normed_field K] {Œæ : K}
  (_ : ‚à•Œæ‚à• < 1) : tendsto (Œª n : ‚Ñï, Œæ^n) at_top (ùìù 0) :=
begin
  rw[tendsto_iff_norm_tendsto_zero],
  convert tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg Œæ) ‚Äπ‚à•Œæ‚à• < 1‚Ä∫,
  ext n,
  simp
end

lemma tendsto_pow_at_top_at_top_of_gt_1_nat {k : ‚Ñï} (h : 1 < k) :
  tendsto (Œªn:‚Ñï, k ^ n) at_top at_top :=
tendsto_coe_nat_real_at_top_iff.1 $
  have hr : 1 < (k : ‚Ñù), by rw [‚Üê nat.cast_one, nat.cast_lt]; exact h,
  by simpa using tendsto_pow_at_top_at_top_of_gt_1 hr

lemma tendsto_inverse_at_top_nhds_0_nat : tendsto (Œª n : ‚Ñï, (n : ‚Ñù)‚Åª¬π) at_top (ùìù 0) :=
tendsto_inv_at_top_zero.comp (tendsto_coe_nat_real_at_top_iff.2 tendsto_id)

lemma tendsto_const_div_at_top_nhds_0_nat (C : ‚Ñù) : tendsto (Œª n : ‚Ñï, C / n) at_top (ùìù 0) :=
by simpa only [mul_zero] using tendsto_const_nhds.mul tendsto_inverse_at_top_nhds_0_nat

lemma tendsto_one_div_add_at_top_nhds_0_nat :
  tendsto (Œª n : ‚Ñï, 1 / ((n : ‚Ñù) + 1)) at_top (ùìù 0) :=
suffices tendsto (Œª n : ‚Ñï, 1 / (‚Üë(n + 1) : ‚Ñù)) at_top (ùìù 0), by simpa,
(tendsto_add_at_top_iff_nat 1).2 (tendsto_const_div_at_top_nhds_0_nat 1)

lemma has_sum_geometric {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) :
  has_sum (Œªn:‚Ñï, r ^ n) (1 - r)‚Åª¬π :=
have r ‚â† 1, from ne_of_lt h‚ÇÇ,
have r + -1 ‚â† 0,
  by rw [‚Üêsub_eq_add_neg, ne, sub_eq_iff_eq_add]; simp; assumption,
have tendsto (Œªn, (r ^ n - 1) * (r - 1)‚Åª¬π) at_top (ùìù ((0 - 1) * (r - 1)‚Åª¬π)),
  from ((tendsto_pow_at_top_nhds_0_of_lt_1 h‚ÇÅ h‚ÇÇ).sub tendsto_const_nhds).mul tendsto_const_nhds,
have (Œª n, (range n).sum (Œª i, r ^ i)) = (Œª n, geom_series r n) := rfl,
(has_sum_iff_tendsto_nat_of_nonneg (pow_nonneg h‚ÇÅ) _).mpr $
  by simp [neg_inv, geom_sum, div_eq_mul_inv, *] at *

lemma summable_geometric {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) : summable (Œªn:‚Ñï, r ^ n) :=
‚ü®_, has_sum_geometric h‚ÇÅ h‚ÇÇ‚ü©

lemma tsum_geometric {r : ‚Ñù} (h‚ÇÅ : 0 ‚â§ r) (h‚ÇÇ : r < 1) : (‚àën:‚Ñï, r ^ n) = (1 - r)‚Åª¬π :=
tsum_eq_has_sum (has_sum_geometric h‚ÇÅ h‚ÇÇ)

lemma has_sum_geometric_two : has_sum (Œªn:‚Ñï, ((1:‚Ñù)/2) ^ n) 2 :=
by convert has_sum_geometric _ _; norm_num

lemma summable_geometric_two : summable (Œªn:‚Ñï, ((1:‚Ñù)/2) ^ n) :=
‚ü®_, has_sum_geometric_two‚ü©

lemma tsum_geometric_two : (‚àën:‚Ñï, ((1:‚Ñù)/2) ^ n) = 2 :=
tsum_eq_has_sum has_sum_geometric_two

lemma has_sum_geometric_two' (a : ‚Ñù) : has_sum (Œªn:‚Ñï, (a / 2) / 2 ^ n) a :=
begin
  convert has_sum_mul_left (a / 2) (has_sum_geometric
    (le_of_lt one_half_pos) one_half_lt_one),
  { funext n, simp,
    rw ‚Üê pow_inv; [refl, exact two_ne_zero] },
  { norm_num, rw div_mul_cancel _ two_ne_zero }
end

lemma summable_geometric_two' (a : ‚Ñù) : summable (Œª n:‚Ñï, (a / 2) / 2 ^ n) :=
‚ü®a, has_sum_geometric_two' a‚ü©

lemma tsum_geometric_two' (a : ‚Ñù) : (‚àë n:‚Ñï, (a / 2) / 2^n) = a :=
tsum_eq_has_sum $ has_sum_geometric_two' a

lemma nnreal.has_sum_geometric {r : nnreal} (hr : r < 1) :
  has_sum (Œª n : ‚Ñï, r ^ n) (1 - r)‚Åª¬π :=
begin
  apply nnreal.has_sum_coe.1,
  push_cast,
  rw [nnreal.coe_sub (le_of_lt hr)],
  exact has_sum_geometric r.coe_nonneg hr
end

lemma nnreal.summable_geometric {r : nnreal} (hr : r < 1) : summable (Œªn:‚Ñï, r ^ n) :=
‚ü®_, nnreal.has_sum_geometric hr‚ü©

lemma tsum_geometric_nnreal {r : nnreal} (hr : r < 1) : (‚àën:‚Ñï, r ^ n) = (1 - r)‚Åª¬π :=
tsum_eq_has_sum (nnreal.has_sum_geometric hr)

/-- The series `pow r` converges to `(1-r)‚Åª¬π`. For `r < 1` the RHS is a finite number,
and for `1 ‚â§ r` the RHS equals `‚àû`. -/
lemma ennreal.tsum_geometric (r : ennreal) : (‚àën:‚Ñï, r ^ n) = (1 - r)‚Åª¬π :=
begin
  cases lt_or_le r 1 with hr hr,
  { rcases ennreal.lt_iff_exists_coe.1 hr with ‚ü®r, rfl, hr'‚ü©,
    norm_cast at *,
    convert ennreal.tsum_coe_eq (nnreal.has_sum_geometric hr),
    rw [ennreal.coe_inv $ ne_of_gt $ nnreal.sub_pos.2 hr] },
  { rw [ennreal.sub_eq_zero_of_le hr, ennreal.inv_zero, ennreal.tsum_eq_supr_nat, supr_eq_top],
    refine Œª a ha, (ennreal.exists_nat_gt (lt_top_iff_ne_top.1 ha)).imp
      (Œª n hn, lt_of_lt_of_le hn _),
    have : ‚àÄ k:‚Ñï, 1 ‚â§ r^k, by simpa using canonically_ordered_semiring.pow_le_pow_of_le_left hr,
    calc (n:ennreal) = (range n).sum (Œª _, 1) : by rw [sum_const, add_monoid.smul_one, card_range]
    ... ‚â§ (range n).sum (pow r) : sum_le_sum (Œª k _, this k) }
end

/-- For any positive `Œµ`, define on an encodable type a positive sequence with sum less than `Œµ` -/
def pos_sum_of_encodable {Œµ : ‚Ñù} (hŒµ : 0 < Œµ)
  (Œπ) [encodable Œπ] : {Œµ' : Œπ ‚Üí ‚Ñù // (‚àÄ i, 0 < Œµ' i) ‚àß ‚àÉ c, has_sum Œµ' c ‚àß c ‚â§ Œµ} :=
begin
  let f := Œª n, (Œµ / 2) / 2 ^ n,
  have hf : has_sum f Œµ := has_sum_geometric_two' _,
  have f0 : ‚àÄ n, 0 < f n := Œª n, div_pos (half_pos hŒµ) (pow_pos two_pos _),
  refine ‚ü®f ‚àò encodable.encode, Œª i, f0 _, _‚ü©,
  rcases summable_comp_of_summable_of_injective f (summable_spec hf) (@encodable.encode_injective Œπ _)
    with ‚ü®c, hg‚ü©,
  refine ‚ü®c, hg, has_sum_le_inj _ (@encodable.encode_injective Œπ _) _ _ hg hf‚ü©,
  { assume i _, exact le_of_lt (f0 _) },
  { assume n, exact le_refl _ }
end

section edist_le_geometric

variables [emetric_space Œ±] (r C : ennreal) (hr : r < 1) (hC : C ‚â† ‚ä§) {f : ‚Ñï ‚Üí Œ±}
  (hu : ‚àÄn, edist (f n) (f (n+1)) ‚â§ C * r^n)

include hr hC hu

/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `C ‚â† ‚àû`, `r < 1`,
then `f` is a Cauchy sequence.-/
lemma cauchy_seq_of_edist_le_geometric : cauchy_seq f :=
begin
  refine cauchy_seq_of_edist_le_of_tsum_ne_top _ hu _,
  rw [ennreal.mul_tsum, ennreal.tsum_geometric],
  refine ennreal.mul_ne_top hC (ennreal.inv_ne_top.2 _),
  exact ne_of_gt (ennreal.zero_lt_sub_iff_lt.2 hr)
end

omit hr hC

/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from
`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/
lemma edist_le_of_edist_le_geometric_of_tendsto {a : Œ±} (ha : tendsto f at_top (ùìù a)) (n : ‚Ñï) :
  edist (f n) a ‚â§ (C * r^n) / (1 - r) :=
begin
  convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _,
  simp only [pow_add, ennreal.mul_tsum, ennreal.tsum_geometric, ennreal.div_def, mul_assoc]
end

/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from
`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/
lemma edist_le_of_edist_le_geometric_of_tendsto‚ÇÄ {a : Œ±} (ha : tendsto f at_top (ùìù a)) :
  edist (f 0) a ‚â§ C / (1 - r) :=
by simpa only [pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0

end edist_le_geometric

section edist_le_geometric_two

variables [emetric_space Œ±] (C : ennreal) (hC : C ‚â† ‚ä§) {f : ‚Ñï ‚Üí Œ±}
  (hu : ‚àÄn, edist (f n) (f (n+1)) ‚â§ C / 2^n) {a : Œ±} (ha : tendsto f at_top (ùìù a))

include hC hu

/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then `f` is a Cauchy sequence.-/
lemma cauchy_seq_of_edist_le_geometric_two : cauchy_seq f :=
begin
  simp only [ennreal.div_def, ennreal.inv_pow'] at hu,
  refine cauchy_seq_of_edist_le_geometric 2‚Åª¬π C _ hC hu,
  simp [ennreal.one_lt_two]
end

omit hC
include ha

/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from
`f n` to the limit of `f` is bounded above by `2 * C * 2^-n`. -/
lemma edist_le_of_edist_le_geometric_two_of_tendsto (n : ‚Ñï) :
  edist (f n) a ‚â§ 2 * C / 2^n :=
begin
  simp only [ennreal.div_def, ennreal.inv_pow'] at hu,
  rw [ennreal.div_def, mul_assoc, mul_comm, ennreal.inv_pow'],
  convert edist_le_of_edist_le_geometric_of_tendsto 2‚Åª¬π C hu ha n,
  rw [ennreal.one_sub_inv_two, ennreal.inv_inv]
end

/-- If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from
`f 0` to the limit of `f` is bounded above by `2 * C`. -/
lemma edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ: edist (f 0) a ‚â§ 2 * C :=
by simpa only [pow_zero, ennreal.div_def, ennreal.inv_one, mul_one]
  using edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0

end edist_le_geometric_two

section le_geometric

variables [metric_space Œ±] {r C : ‚Ñù} (hr : r < 1) {f : ‚Ñï ‚Üí Œ±}
  (hu : ‚àÄn, dist (f n) (f (n+1)) ‚â§ C * r^n)

include hr hu

lemma aux_has_sum_of_le_geometric : has_sum (Œª n : ‚Ñï, C * r^n) (C / (1 - r)) :=
begin
  have h0 : 0 ‚â§ C,
    by simpa using le_trans dist_nonneg (hu 0),
  rcases eq_or_lt_of_le h0 with rfl | Cpos,
  { simp [has_sum_zero] },
  { have rnonneg: r ‚â• 0, from nonneg_of_mul_nonneg_left
      (by simpa only [pow_one] using le_trans dist_nonneg (hu 1)) Cpos,
    refine has_sum_mul_left C _,
    by simpa using has_sum_geometric rnonneg hr }
end

variables (r C)

/-- If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence.
Note that this lemma does not assume `0 ‚â§ C` or `0 ‚â§ r`. -/
lemma cauchy_seq_of_le_geometric : cauchy_seq f :=
cauchy_seq_of_dist_le_of_summable _ hu ‚ü®_, aux_has_sum_of_le_geometric hr hu‚ü©

/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from
`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. -/
lemma dist_le_of_le_geometric_of_tendsto‚ÇÄ {a : Œ±} (ha : tendsto f at_top (ùìù a)) :
  dist (f 0) a ‚â§ C / (1 - r) :=
(tsum_eq_has_sum $ aux_has_sum_of_le_geometric hr hu) ‚ñ∏
  dist_le_tsum_of_dist_le_of_tendsto‚ÇÄ _ hu ‚ü®_, aux_has_sum_of_le_geometric hr hu‚ü© ha

/-- If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from
`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. -/
lemma dist_le_of_le_geometric_of_tendsto {a : Œ±} (ha : tendsto f at_top (ùìù a)) (n : ‚Ñï) :
  dist (f n) a ‚â§ (C * r^n) / (1 - r) :=
begin
  have := aux_has_sum_of_le_geometric hr hu,
  convert dist_le_tsum_of_dist_le_of_tendsto _ hu ‚ü®_, this‚ü© ha n,
  simp only [pow_add, mul_left_comm C, mul_div_right_comm],
  rw [mul_comm],
  exact (eq.symm $ tsum_eq_has_sum $ has_sum_mul_left _ this)
end

omit hr hu

variable (hu‚ÇÇ : ‚àÄ n, dist (f n) (f (n+1)) ‚â§ (C / 2) / 2^n)

/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/
lemma cauchy_seq_of_le_geometric_two : cauchy_seq f :=
cauchy_seq_of_dist_le_of_summable _ hu‚ÇÇ $ ‚ü®_, has_sum_geometric_two' C‚ü©

/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from
`f 0` to the limit of `f` is bounded above by `C`. -/
lemma dist_le_of_le_geometric_two_of_tendsto‚ÇÄ {a : Œ±} (ha : tendsto f at_top (ùìù a)) :
  dist (f 0) a ‚â§ C :=
(tsum_geometric_two' C) ‚ñ∏ dist_le_tsum_of_dist_le_of_tendsto‚ÇÄ _ hu‚ÇÇ (summable_geometric_two' C) ha

include hu‚ÇÇ

/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from
`f n` to the limit of `f` is bounded above by `C / 2^n`. -/
lemma dist_le_of_le_geometric_two_of_tendsto {a : Œ±} (ha : tendsto f at_top (ùìù a)) (n : ‚Ñï) :
  dist (f n) a ‚â§ C / 2^n :=
begin
  convert dist_le_tsum_of_dist_le_of_tendsto _ hu‚ÇÇ (summable_geometric_two' C) ha n,
  simp only [add_comm n, pow_add, (div_div_eq_div_mul _ _ _).symm],
  symmetry,
  exact tsum_eq_has_sum (has_sum_mul_right _ $ has_sum_geometric_two' C)
end

end le_geometric

namespace nnreal

theorem exists_pos_sum_of_encodable {Œµ : nnreal} (hŒµ : 0 < Œµ) (Œπ) [encodable Œπ] :
  ‚àÉ Œµ' : Œπ ‚Üí nnreal, (‚àÄ i, 0 < Œµ' i) ‚àß ‚àÉc, has_sum Œµ' c ‚àß c < Œµ :=
let ‚ü®a, a0, aŒµ‚ü© := dense hŒµ in
let ‚ü®Œµ', hŒµ', c, hc, hcŒµ‚ü© := pos_sum_of_encodable a0 Œπ in
‚ü® Œªi, ‚ü®Œµ' i, le_of_lt $ hŒµ' i‚ü©, assume i, nnreal.coe_lt.2 $ hŒµ' i,
  ‚ü®c, has_sum_le (assume i, le_of_lt $ hŒµ' i) has_sum_zero hc ‚ü©, nnreal.has_sum_coe.1 hc,
   lt_of_le_of_lt (nnreal.coe_le.1 hcŒµ) aŒµ ‚ü©

end nnreal

namespace ennreal

theorem exists_pos_sum_of_encodable {Œµ : ennreal} (hŒµ : 0 < Œµ) (Œπ) [encodable Œπ] :
  ‚àÉ Œµ' : Œπ ‚Üí nnreal, (‚àÄ i, 0 < Œµ' i) ‚àß (‚àë i, (Œµ' i : ennreal)) < Œµ :=
begin
  rcases dense hŒµ with ‚ü®r, h0r, hrŒµ‚ü©,
  rcases lt_iff_exists_coe.1 hrŒµ with ‚ü®x, rfl, hx‚ü©,
  rcases nnreal.exists_pos_sum_of_encodable (coe_lt_coe.1 h0r) Œπ with ‚ü®Œµ', hp, c, hc, hcr‚ü©,
  exact ‚ü®Œµ', hp, (ennreal.tsum_coe_eq hc).symm ‚ñ∏ lt_trans (coe_lt_coe.2 hcr) hrŒµ‚ü©
end

end ennreal
